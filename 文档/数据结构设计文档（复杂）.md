# 渐进式学习思维导图数据结构设计文档

## 概述

本文档定义了支持卡片笔记关联和时间演绎动画功能的极简数据结构设计。设计原则：先做对，再做快。避免过度设计，保持简洁高效。

## 1. 节点级数据结构（核心）

### 1.1 卡片笔记数据 (cardNotes)

**用途**: 存储节点关联的Obsidian卡片笔记信息

```
cardNotes: [
  {
    path: "项目语境/2025-01/15-学习笔记.md",
    basename: "15-学习笔记",
    addedAt: "2025-01-15"
  }
]
```

**特点**:
- 支持最多20个卡片关联
- 只存储必需字段，避免冗余
- `addedAt`用于时间轴动画过滤

### 1.2 学习活动记录 (dailyActivity)

**用途**: 按日期记录学习活动和掌握状态

```
dailyActivity: {
  "2025-01-15": {
    cardLinksAdded: 3,           // 当天新增卡片数
    masteryTriggered: true,      // 是否触发掌握（二元状态）
    isFirstMastery: true         // 是否为首次掌握
  },
  "2025-01-25": {
    cardLinksAdded: 1,
    masteryTriggered: true,
    isFirstMastery: false        // 复习掌握
  },
  "2025-01-26": {
    cardLinksAdded: 2,
    masteryTriggered: false      // 未触发掌握
  }
}
```

### 1.3 预计算统计缓存 (cachedStats)

**用途**: 存储预计算的聚合统计，避免实时计算导致卡顿

```
cachedStats: {
  totalDescendantCards: 25,      // 包含所有子节点的卡片总数
  maxDescendantMastery: 0.85,    // 子树中最高熟悉度
  activeDescendantCount: 12,     // 有卡片的子节点数量
  lastStatsUpdate: "2025-01-20"  // 统计最后更新时间
}
```

**维护策略**:
- 添加/删除卡片时：同步更新从当前节点到根节点的所有统计
- 掌握状态变化时：更新相关的熟悉度统计
- 确保数据变更时的增量更新，避免全量重算

**掌握逻辑**:
- **首次学习**: 当天添加≥3张卡片 → 自动标记掌握
- **复习**: 当天添加≥1张卡片 → 自动标记掌握
- **判断依据**: 查找历史记录中是否有 `masteryTriggered: true`

**熟悉度计算**:
- 基于最后掌握日期和当前日期的时间差实时计算
- 使用遗忘曲线公式：`熟悉度 = e^(-衰减率 × 天数)`
- 不存储熟悉度值，避免数据不一致

## 2. 思维导图级配置（最小化）

### 2.1 时间轴配置 (timelineConfig)

```
timelineConfig: {
  currentViewDate: "2025-01-20",  // 当前查看日期
  animationSpeed: 1.0             // 动画播放倍速
}
```

### 2.2 元数据 (metadata)

```
metadata: {
  lastUpdate: "2025-01-20T14:30:00Z"  // 最后更新时间
}
```

## 3. 运行时状态（内存存储）

### 3.1 动画状态 (animationState)

```
animationState: {
  isAnimating: false,           // 是否正在播放动画
  currentDate: "2025-01-15",   // 当前动画日期
  playbackSpeed: 1.0           // 播放倍速
}
```

## 4. 实时计算的数据（不存储）

以下数据通过遍历节点实时计算，避免数据冗余和不一致：

### 4.1 统计数据
- 总卡片链接数：遍历所有节点的 `cardNotes` 数组
- 总节点数：节点数组长度
- 活跃节点数：过滤有卡片的节点
- 平均熟悉度：计算所有节点熟悉度的平均值

### 4.2 索引查询
- 按日期查询：遍历节点的 `dailyActivity` 和 `cardNotes[].addedAt`
- 按卡片查询：遍历节点的 `cardNotes[]` 找包含指定卡片的节点
- 按节点查询：直接访问节点的数据字段

### 4.3 动画所需数据
- 可见节点：根据时间范围过滤有活动的节点
- 熟悉度颜色：基于遗忘曲线实时计算
- 卡片数量变化：对比前后日期的累计卡片数

## 5. 数据持久化策略

### 5.1 存储内容（.smm.md文件）
- 节点的 `cardNotes` 和 `dailyActivity`
- `timelineConfig` 和 `metadata`
- 使用LZ压缩减少文件大小

### 5.2 不存储内容
- 全局统计数据（实时计算）
- 索引映射（实时查询）
- 动画状态（运行时）
- 临时计算结果

## 6. 实现方向指引

### 6.1 核心函数设计

**节点数据操作**:
```javascript
// 添加卡片笔记（包含统计维护）
function addCardToNode(nodeId, cardInfo) {
  // 1. 更新节点自身数据
  node.cardNotes.push(cardInfo)
  node.dailyActivity[today].cardLinksAdded++

  // 2. 同步更新父节点统计
  updateAncestorStats(nodeId, +1)

  // 3. 检查是否触发掌握
  checkAndTriggerMastery(nodeId, today)
}

// 增量更新祖先节点统计
function updateAncestorStats(nodeId, cardDelta, masteryDelta = 0) {
  const parent = getParentNode(nodeId)
  if (parent) {
    parent.cachedStats.totalDescendantCards += cardDelta
    if (masteryDelta) {
      parent.cachedStats.maxDescendantMastery = recalculateMaxMastery(parent)
    }
    updateAncestorStats(parent.id, cardDelta, masteryDelta)
  }
}
```

**时间轴查询**:
```javascript
// 获取指定日期的活跃节点（基于展开/收缩策略）
getActiveNodesOnDate(date)
// 获取节点在指定日期的卡片数（直接读取缓存）
getNodeCardCountOnDate(nodeId, date)
// 计算节点当前熟悉度
getNodeMasteryLevel(nodeId, currentDate)
```

### 6.2 组件交互流程

**卡片添加流程**:
1. 用户选择卡片 → NodeCard组件
2. 调用 `addCardToNode()` 更新节点数据
3. 检查并触发自动掌握逻辑
4. 触发界面重新渲染

**动画播放流程**:
1. 用户拖动时间轴 → 更新 `currentViewDate`
2. 实时计算当前日期的可见节点和熟悉度
3. 触发展开/收缩和颜色变化动画
4. 更新数字按钮显示

### 6.3 性能优化策略

#### 6.3.1 渲染优化（基于展开/收缩状态）
```
时间轴驱动的节点显示策略：
- 有活动的节点：展开显示，完整渲染
- 无活动的节点：收缩隐藏，简化渲染
- 收缩状态的父节点：直接读取 cachedStats 显示聚合数字
```

#### 6.3.2 统计维护策略
```
增量更新原则：
1. 数据变更时同步维护统计，而非使用时计算
2. 添加卡片时：递归更新从节点到根节点的所有 cachedStats
3. 用户查看时：直接读取预计算结果，无需等待
```

#### 6.3.3 大规模数据处理
```
分层渲染策略：
- 当前时间焦点区域：完整渲染所有细节
- 相邻时间区域：基础渲染，减少动画效果
- 远离焦点区域：最简渲染或隐藏
```

## 7. 避免的过度设计

### 7.1 避免的过度设计
- ❌ 多层索引映射（`cardNotesMapping`）
- ❌ 全局预计算缓存（`precomputedCache`）
- ❌ 复杂的动画队列系统
- ❌ 懒计算统计（用时再算）

### 7.2 采用的简化原则
- ✅ 数据单一来源，避免重复存储
- ✅ 节点级预计算统计，全局实时计算
- ✅ 掌握状态用二元值，不用连续值
- ✅ 熟悉度基于时间衰减实时计算
- ✅ 增量维护代替全量重算

这个极简设计既满足功能需求，又保持了代码的可维护性和扩展性。在实际使用中如果遇到性能问题，再有针对性地添加优化。